// src/app/layout.js
import { Geist, Geist_Mono } from "next/font/google";
import "./globals.css";
import { JobsProvider } from "../hooks/useJobs";

const geistSans = Geist({
    variable: "--font-geist-sans",
    subsets: ["latin"],
});

const geistMono = Geist_Mono({
    variable: "--font-geist-mono",
    subsets: ["latin"],
});

export const metadata = {
    title: "ACTS - Audio Recording & Creative Transcription System",
    description: "Transcribe and generate content from audio files and YouTube video powered by Tim Digital Garuda TV",
    icon: "/favicon.ico",
};

export default function RootLayout({ children }) {
    return (
        <html lang="en">
            <body
                className={`
          ${geistSans.variable} 
          ${geistMono.variable} 
          antialiased 
          flex 
          flex-col 
          min-h-screen 
          bg-gray-50 
          text-gray-900
        `}
            >
                {/* Wrap the entire app with JobsProvider */}
                <JobsProvider>{children}</JobsProvider>

                {/* Global Footer */}
                <footer className="w-full bg-slate-700 py-6 mt-8">
                    <div className="container mx-auto text-center px-4">
                        {/* Powered by Section */}
                        <p className="text-xs text-gray-300">Powered by:</p>
                        <a
                            href="https://garuda.tv"
                            target="_blank"
                            rel="noopener noreferrer"
                            className="inline-block mt-2 mb-3"
                        >
                            <img
                                src="https://garuda.tv/wp-content/uploads/2024/12/Logo_GarudaTV_Merah_Flat_2025.svg"
                                alt="Logo GarudaTV"
                                className="mx-auto w-auto h-12 p-2"
                            />
                        </a>

                        {/* Disclaimer */}
                        <p className="text-sm text-gray-300 max-w-2xl mx-auto leading-relaxed">
                            Disclaimer: Always verify the information generated by this tool with official sources before making any publication.
                            The generated content is for informational & educational purposes only.
                        </p>

                        {/* Horizontal Divider */}
                        <hr className="border-gray-500 my-4" />

                        {/* Copyright Notice */}
                        <p className="text-xs text-gray-400 mt-4">
                            © {new Date().getFullYear()} Divisi Digital Garuda TV. All rights reserved.
                        </p>
                    </div>
                </footer>
            </body>
        </html>
    );
}// src/app/page.js
"use client";

import { useState, useEffect, useRef } from "react";
import { useRouter } from "next/navigation";
import useAuth from "../hooks/useAuth";
import useHistory from "../hooks/useHistory";
import { useJobs } from "../hooks/useJobs";
import TranscribeSection from "../components/TranscribeSection";
import TranscriptionHistory from "../components/TranscriptionHistory";
import ContentHistory from "../components/ContentHistory";
import ProcessingQueue from "../components/ProcessingQueue";

export default function Home() {
  const user = useAuth();
  const { transcriptionHistory, contentHistory, refreshHistory } = useHistory(user);
  const { processingQueue, isLoading } = useJobs();  // Add isLoading from useJobs
  const router = useRouter();

  const [showWarning, setShowWarning] = useState(() => {
    if (typeof window !== "undefined") {
      return localStorage.getItem("showWarning") !== "false";
    }
    return true;
  });

  const dismissWarning = () => {
    setShowWarning(false);
    localStorage.setItem("showWarning", "false");
  };

  const prevQueueRef = useRef([]);

  useEffect(() => {
    processingQueue.forEach((currentJob) => {
      const oldJob = prevQueueRef.current.find((j) => j.job_id === currentJob.job_id);
      if (oldJob && oldJob.status !== "completed" && currentJob.status === "completed") {
        refreshHistory();
      }
    });
    prevQueueRef.current = processingQueue;
  }, [processingQueue, refreshHistory]);

  if (!user) return null;

  return (
    <div className="max-w-7xl mx-auto w-full px-4 py-8 flex flex-col">
      <h1 className="text-3xl font-bold text-center mb-2">
        ACTS (Audio Recording & Creative Transcription System)
      </h1>
      <p className="text-gray-600 text-center mb-6">
        Logged in as: <span className="font-medium">{user.email}</span>
      </p>

      {showWarning && (
        <div className="bg-yellow-100 border-l-4 border-yellow-500 text-yellow-900 p-4 rounded-lg mb-6 relative">
          <button
            onClick={dismissWarning}
            className="absolute top-2 right-2 text-yellow-700 hover:text-yellow-900"
          >
            ✖
          </button>
          <h2 className="font-bold text-lg">⚠️ Before using this tool:</h2>
          <ul className="list-disc list-inside mt-2 space-y-1">
            <li>Ensure your audio/video is within the recommended length (max 15 - 30 minutes).</li>
            <li>Keep file sizes manageable (less than 25MB).</li>
            <li>Make sure your YouTube link is valid and not region-locked.</li>
            <li>Be aware of copyrighted content.</li>
            <li>Exceeding the recommended duration may result in incomplete/failed transcriptions.</li>
            <li>This tool is for informational & educational purposes only.</li>
          </ul>
        </div>
      )}

      <div className="grid grid-cols-1 lg:grid-cols-10 gap-6">
        <div className="col-span-1 lg:col-span-3 bg-white p-6 rounded-lg shadow h-[28rem] flex items-center">
          <div className="w-full">
            <TranscribeSection />
          </div>
        </div>

        <div className="col-span-1 lg:col-span-5 bg-white p-6 rounded-lg shadow h-[28rem] overflow-y-auto">
          <TranscriptionHistory
            transcriptionHistory={transcriptionHistory}
            onDone={refreshHistory}
          />
        </div>

        <div className="col-span-1 lg:col-span-2 bg-white p-6 rounded-lg shadow h-[28rem] overflow-y-auto">
          <ProcessingQueue processingQueue={processingQueue} isLoading={isLoading} />
        </div>
      </div>

      <div className="mt-6 grid grid-cols-1 lg:grid-cols-10 gap-6">
        <div className="col-span-1 lg:col-span-6 bg-white p-6 rounded-lg shadow h-[28rem] overflow-y-auto">
          <ContentHistory contentHistory={contentHistory} />
        </div>

        <div className="col-span-1 lg:col-span-4 bg-white p-6 rounded-lg shadow h-[28rem] overflow-y-auto">
          <StatsOverview
            transcriptionCount={transcriptionHistory.length}
            contentCount={contentHistory.length}
          />
        </div>
      </div>

      <button
        onClick={() => {
          localStorage.removeItem("token");
          router.push("/login");
        }}
        className="mt-6 bg-red-500 hover:bg-red-600 text-white py-2 px-4 rounded-md mx-auto w-full max-w-xs"
      >
        Logout
      </button>
    </div>
  );
}

function StatsOverview({ transcriptionCount, contentCount }) {
  return (
    <div>
      <h2 className="text-xl font-bold mb-4">User Stats</h2>
      <ul className="space-y-2">
        <li>
          <strong>Total Transcriptions:</strong> {transcriptionCount}
        </li>
        <li>
          <strong>Total Content Generated:</strong> {contentCount}
        </li>
      </ul>
    </div>
  );
}// frontend/src/app/login/page.js
"use client";

import { useState } from "react";
import axios from "axios";
import { useRouter } from "next/navigation";

export default function Login() {
    const [email, setEmail] = useState("");
    const [password, setPassword] = useState("");
    const [error, setError] = useState("");
    const router = useRouter();

    const API_BASE_URL = process.env.NEXT_PUBLIC_API_BASE_URL || "http://127.0.0.1:3000";

    const handleSubmit = async (e) => {
        e.preventDefault();

        if (!email || !password) {
            setError("Please fill in both fields.");
            return;
        }

        try {
            const response = await axios.post(`${API_BASE_URL}/auth/login`, {
                email,
                password,
            }, {
                withCredentials: true, // Enable cookies
            });

            // No need to store token in localStorage; backend sets HTTP-only cookie
            router.push("/");
        } catch (err) {
            console.error(err);
            setError("Invalid email or password.");
        }
    };

    return (
        <div className="flex justify-center items-center min-h-screen bg-gray-50 px-4">
            <div className="bg-white p-8 rounded-lg shadow w-full max-w-md">
                <h1 className="text-2xl font-bold text-center mb-6">Login</h1>
                {error && <p className="text-red-500 text-center mb-4">{error}</p>}
                <form onSubmit={handleSubmit}>
                    <div className="mb-4">
                        <label htmlFor="email" className="block text-sm font-semibold text-gray-700 mb-1">
                            Email
                        </label>
                        <input
                            type="email"
                            id="email"
                            name="email"
                            value={email}
                            onChange={(e) => setEmail(e.target.value)}
                            className="w-full px-4 py-2 border border-gray-300 rounded focus:outline-none focus:ring-2 focus:ring-blue-500"
                            required
                        />
                    </div>
                    <div className="mb-6">
                        <label htmlFor="password" className="block text-sm font-semibold text-gray-700 mb-1">
                            Password
                        </label>
                        <input
                            type="password"
                            id="password"
                            name="password"
                            value={password}
                            onChange={(e) => setPassword(e.target.value)}
                            className="w-full px-4 py-2 border border-gray-300 rounded focus:outline-none focus:ring-2 focus:ring-blue-500"
                            required
                        />
                    </div>
                    <button
                        type="submit"
                        className="w-full bg-blue-500 hover:bg-blue-600 text-white py-2 rounded focus:outline-none focus:ring-2 focus:ring-blue-500"
                    >
                        Login
                    </button>
                </form>
            </div>
        </div>
    );
}// src/utils/api.js
import axios from "axios";

const API_BASE_URL = process.env.NEXT_PUBLIC_API_BASE_URL || "http://127.0.0.1:3000";

const apiClient = axios.create({
    baseURL: API_BASE_URL,
    withCredentials: true,
});

apiClient.interceptors.response.use(
    response => response,
    error => {
        if (error.response && error.response.status === 401) {
            window.location.href = "/login";
        }
        return Promise.reject(error);
    }
);

export const getUser = async () => {
    return apiClient.get(`/auth/me`);
};

export const fetchHistory = async () => {
    const [transcriptionsRes, contentsRes] = await Promise.all([
        apiClient.get(`/history/`),
        apiClient.get(`/content-history/`),
    ]);

    return [
        { data: transcriptionsRes.data },
        { data: contentsRes.data },
    ];
};

export default apiClient;// src/components/ProcessingQueue.js
"use client";

import { useEffect } from "react";

export default function ProcessingQueue({ processingQueue }) {
    useEffect(() => {
        console.log("🟢 ProcessingQueue Updated:", processingQueue);
    }, [processingQueue]);

    // Sort the jobs by created_at descending so the newest job is first
    const sortedJobs = (processingQueue || []).slice().sort((a, b) => {
        // If either is missing a created_at, treat that as "older" (just in case)
        const dateA = a.created_at ? new Date(a.created_at) : new Date(0);
        const dateB = b.created_at ? new Date(b.created_at) : new Date(0);
        return dateB - dateA;
    });

    return (
        <div>
            <h2 className="text-xl font-bold mb-4">Ongoing Jobs</h2>
            <div className="space-y-3">
                {sortedJobs.length > 0 ? (
                    sortedJobs.map((job) => (
                        <div
                            key={job.job_id}
                            className={`p-4 rounded-lg shadow cursor-pointer transition ${job.status === "processing" ? "bg-blue-100" : "bg-gray-50"
                                } hover:bg-gray-200`}
                        >
                            <p className="font-semibold">{job.title || "Untitled Job"}</p>
                            <p className="text-xs text-gray-500">Status: {job.status}</p>

                            {/* Show creation time if available */}
                            {job.created_at && (
                                <p className="text-xs text-gray-400 mt-1">
                                    Created: {new Date(job.created_at).toLocaleString()}
                                </p>
                            )}

                            {/* Show completion time if job is completed */}
                            {job.status === "completed" && job.completed_at && (
                                <p className="text-xs text-gray-400">
                                    Completed: {new Date(job.completed_at).toLocaleString()}
                                </p>
                            )}
                        </div>
                    ))
                ) : (
                    <p className="text-gray-500">No ongoing jobs.</p>
                )}
            </div>
        </div>
    );
}// src/components/StatsOverview.js
"use client";
// ^ If you need to use state/hooks or other client-side features

export default function StatsOverview({ transcriptionCount, contentCount }) {
    return (
        <div className="bg-white p-6 rounded-lg shadow mb-6">
            <h3 className="text-lg font-bold mb-2">Stats Overview</h3>
            <p className="text-gray-600">
                <strong>Transcriptions:</strong> {transcriptionCount}
            </p>
            <p className="text-gray-600">
                <strong>Generated Content:</strong> {contentCount}
            </p>
        </div>
    );
}// src/components/TranscriptionHistory.js

"use client";

import { useState } from "react";
import TranscriptionModal from "./TranscriptionModal";

export default function TranscriptionHistory({ transcriptionHistory, onDone = () => { }, onJobUpdate = () => { }, }) {
    const [selectedTranscription, setSelectedTranscription] = useState(null);
    const [isModalOpen, setIsModalOpen] = useState(false);

    // Ensure transcriptionHistory is an array
    const safeTranscriptionHistory = Array.isArray(transcriptionHistory)
        ? transcriptionHistory
        : [];

    return (
        <div>
            <h2 className="text-xl font-bold mb-4">Transcribed Audio</h2>
            <div className="space-y-3">
                {safeTranscriptionHistory.length === 0 ? (
                    <p className="text-gray-500">No transcriptions found.</p>
                ) : (
                    safeTranscriptionHistory
                        .sort((a, b) => new Date(b.created_at) - new Date(a.created_at))
                        .map((transcription) => (
                            <div
                                key={transcription.id}
                                className="bg-gray-50 p-4 rounded-lg shadow cursor-pointer overflow-hidden hover:bg-gray-100 transition"
                                onClick={() => {
                                    setSelectedTranscription(transcription);
                                    setIsModalOpen(true);
                                }}
                            >
                                <p className="font-semibold truncate text-gray-900">
                                    {transcription.title?.trim() || "Untitled Transcription"}
                                </p>
                                <p className="text-sm text-gray-600">{transcription.source}</p>
                                <p className="text-xs text-gray-500">
                                    {new Date(transcription.created_at).toLocaleString()}
                                </p>
                            </div>
                        ))
                )}
            </div>

            {isModalOpen && selectedTranscription && (
                <TranscriptionModal
                    transcription={selectedTranscription}
                    isOpen={isModalOpen}
                    onClose={() => setIsModalOpen(false)}
                    onDone={onDone} // Now defined via default prop
                    onJobUpdate={onJobUpdate} // Forward to TranscriptionModal
                />
            )}
        </div>
    );
}// src/components/ContentHistory.js

"use client";

import { useState } from "react";
import ContentModal from "./ContentModal";

export default function ContentHistory({ contentHistory }) {
    const [selectedContent, setSelectedContent] = useState(null);
    const [isModalOpen, setIsModalOpen] = useState(false);

    return (
        <div>
            <h2 className="text-xl font-bold mb-4">Content Generation History</h2>
            {contentHistory.length === 0 ? (
                <p>No generated content found.</p>
            ) : (
                [...contentHistory]
                    .sort((a, b) => new Date(b.created_at) - new Date(a.created_at))
                    .map((entry) => (
                        <div
                            key={entry.id}
                            className="border-b py-2 cursor-pointer hover:bg-gray-100 transition"
                            onClick={() => {
                                setSelectedContent(entry);
                                setIsModalOpen(true);
                            }}
                        >
                            <p className="font-semibold">
                                {entry.transcription_title || "Unknown Source"}
                            </p>
                            <p className="text-sm text-gray-600">
                                {new Date(entry.created_at).toLocaleString()}
                            </p>
                        </div>
                    ))
            )}

            {isModalOpen && (
                <ContentModal
                    content={selectedContent}
                    onClose={() => setIsModalOpen(false)}
                    isOpen={isModalOpen}
                />
            )}
        </div>
    );
}// src/components/ContentGeneration.js
"use client";

import { useState } from "react";
import axios from "axios";
import { v4 as uuidv4 } from 'uuid';

export default function ContentGeneration({ transcriptionHistory, onJobUpdate, onDone }) {
    const [selectedTranscription, setSelectedTranscription] = useState("");
    const [isGenerating, setIsGenerating] = useState(false);

    const configDefaults = {
        "Gaya Bahasa": "Formal",
        "Kepadatan Informasi": "Ringkas",
        "Sentimen Terhadap Objek Berita": "Netral",
        "Gaya Penyampaian": "Langsung",
        "Format Output": "Artikel",
        "Gaya Kutipan": "Langsung",
        "Pilihan Bahasa & Dialek": "Baku",
        "Penyuntingan Otomatis": "Tanpa Sensor",
        "Catatan Tambahan": ""
    };

    const API_BASE_URL = process.env.NEXT_PUBLIC_API_BASE_URL || "http://127.0.0.1:3000";

    const handleGenerateContent = async () => {
        if (!selectedTranscription) {
            alert("Please select a transcription first.");
            return;
        }

        const localJobId = uuidv4();
        const selectedObj = transcriptionHistory.find(
            (t) => t.id === parseInt(selectedTranscription)
        );
        const jobTitle = selectedObj
            ? selectedObj.title || selectedObj.transcript.slice(0, 30)
            : "Content Generation";

        onJobUpdate({
            job_id: localJobId,
            status: "pending",
            type: "content-generation",
            title: `Content: ${jobTitle}`
        });

        setIsGenerating(true);

        try {
            const requestBody = {
                transcription_id: parseInt(selectedTranscription),
                transcription: selectedObj ? selectedObj.transcript : "",
                gaya_bahasa: configDefaults["Gaya Bahasa"],
                kepadatan_informasi: configDefaults["Kepadatan Informasi"],
                sentimen: configDefaults["Sentimen Terhadap Objek Berita"],
                gaya_penyampaian: configDefaults["Gaya Penyampaian"],
                format_output: configDefaults["Format Output"],
                gaya_kutipan: configDefaults["Gaya Kutipan"],
                bahasa: configDefaults["Pilihan Bahasa & Dialek"],
                penyuntingan: configDefaults["Penyuntingan Otomatis"],
                catatan_tambahan: configDefaults["Catatan Tambahan"],
                config: configDefaults,
            };

            await axios.post(
                `${API_BASE_URL}/generate/`,
                requestBody,
                { withCredentials: true } // Use cookie auth
            );

            onJobUpdate({
                job_id: localJobId,
                status: "completed",
                type: "content-generation",
                title: `Content: ${jobTitle}`
            });

            if (onDone) onDone();
        } catch (error) {
            console.error("Error generating content:", error);
            alert("Failed to generate content.");
            onJobUpdate({
                job_id: localJobId,
                status: "failed",
                type: "content-generation",
                title: `Content: ${jobTitle}`
            });
        } finally {
            setIsGenerating(false);
        }
    };

    return (
        <div className="bg-white p-6 rounded-lg shadow-md w-full *:max-w-md mx-auto">
            <h2 className="text-xl font-bold mb-4">Generate Content</h2>
            <select
                value={selectedTranscription}
                onChange={(e) => setSelectedTranscription(e.target.value)}
                className="w-full p-2 border rounded mb-2"
            >
                <option value="">Select a transcription</option>
                {transcriptionHistory.map((entry) => (
                    <option key={entry.id} value={entry.id}>
                        {entry.transcript.slice(0, 30)}...
                    </option>
                ))}
            </select>
            <button
                onClick={handleGenerateContent}
                className="w-full bg-purple-500 text-white py-2 rounded-md mt-2"
                disabled={isGenerating}
            >
                {isGenerating ? "Generating..." : "Generate Content"}
            </button>
        </div>
    );
}// src/components/ContentModal.js
"use client";

import React from "react";
import DOMPurify from "dompurify";

export default function ContentModal({ isOpen, onClose, content }) {
    if (!isOpen || !content) return null;

    // Attempt to parse the config if it comes in as a string:
    let configObj = {};
    try {
        configObj =
            typeof content.config === "string"
                ? JSON.parse(content.config)
                : content.config || {};
    } catch (e) {
        console.error("Error parsing config:", e);
    }

    return (
        <div className="fixed inset-0 flex items-center justify-center bg-black bg-opacity-50 p-4">
            <div className="bg-white p-6 rounded-lg shadow-lg max-w-6xl w-full h-[80vh] flex flex-col">
                <h2 className="text-xl font-bold mb-4">Generated Content</h2>

                {/* Two-column layout (30% : 70%) with flexible, scrollable columns */}
                <div className="flex-1 grid grid-cols-[30%,70%] gap-4 overflow-hidden">

                    {/* Column 1: Info & Config */}
                    <div className="flex flex-col h-full border-r pr-4 overflow-y-auto">
                        <p className="text-sm text-gray-600 mb-2">
                            <strong>Transcription Source:</strong>{" "}
                            {content.transcription_title || content.title || "Unknown"}
                        </p>

                        <p className="text-sm text-gray-600 mb-4">
                            <strong>Created At:</strong>{" "}
                            {new Date(content.created_at).toLocaleString()}
                        </p>

                        {Object.keys(configObj).length > 0 ? (
                            <div className="border p-4 rounded-md bg-gray-50 mb-4">
                                <h3 className="text-lg font-bold mb-2">Your Configuration:</h3>
                                <ul className="list-disc pl-4">
                                    {Object.entries(configObj).map(([key, value]) => (
                                        <li key={key}>
                                            <strong>{key}:</strong> {value}
                                        </li>
                                    ))}
                                </ul>
                            </div>
                        ) : (
                            <div className="border p-4 rounded-md bg-gray-50 mb-4">
                                <p>No configuration found.</p>
                            </div>
                        )}
                    </div>

                    {/* Column 2: Generated Content */}
                    <div className="flex flex-col h-full overflow-y-auto">
                        <div className="border p-4 bg-gray-100 rounded-md flex-1 overflow-y-auto">
                            <div
                                className="generated-content"
                                dangerouslySetInnerHTML={{
                                    __html: DOMPurify.sanitize(content.generated_content),
                                }}
                            />
                        </div>
                    </div>
                </div>

                {/* Close button at the bottom */}
                <div className="mt-4 flex justify-end">
                    <button
                        onClick={onClose}
                        className="bg-red-500 text-white px-4 py-2 rounded-md hover:bg-red-600"
                    >
                        Close
                    </button>
                </div>
            </div>
        </div>
    );
}// src/components/TranscriptionModal.js
"use client";

import { useState } from "react";
import axios from "axios";
import { v4 as uuidv4 } from "uuid";
import { useJobs } from "../hooks/useJobs";
import DOMPurify from "dompurify";

export default function TranscriptionModal({
    isOpen,
    onClose,
    transcription,
    onDone = () => { },
}) {
    if (!isOpen || !transcription) return null;

    const apiBaseUrl = process.env.NEXT_PUBLIC_API_BASE_URL;
    const audioSrc = transcription.video_url.startsWith('http')
        ? transcription.video_url
        : `${apiBaseUrl}${transcription.video_url}`;
    const { addJob, updateJobStatus } = useJobs();

    const [step, setStep] = useState(1);
    const [loading, setLoading] = useState(false);
    const [generatedContent, setGeneratedContent] = useState("");
    const [selectedOptions, setSelectedOptions] = useState({
        "Gaya Bahasa": "Netral",
        "Kepadatan Informasi": "Ringkas",
        "Sentimen Terhadap Objek Berita": "Netral",
        "Gaya Penyampaian": "Langsung",
        "Format Output": "Artikel",
        "Gaya Kutipan": "Langsung",
        "Pilihan Bahasa & Dialek": "Baku",
        "Penyuntingan Otomatis": "Tanpa Sensor",
    });
    const [additionalNotes, setAdditionalNotes] = useState("");

    const dropdownOptions = {
        "Gaya Bahasa": ["Netral", "Santai", "Formal", "Sastra", "Provokatif"],
        "Kepadatan Informasi": ["Ringkas", "Sedang", "Lengkap", "Mendetail"],
        "Sentimen Terhadap Objek Berita": ["Netral", "Positif", "Negatif"],
        "Gaya Penyampaian": ["Langsung", "Naratif", "Analitis", "Deskriptif"],
        "Format Output": ["Artikel", "Berita", "Esai", "Opini", "Caption Instagram", "Caption Facebook", "Tweet/Cuitan"],
        "Gaya Kutipan": ["Langsung", "Tidak Langsung", "Campuran"],
        "Pilihan Bahasa & Dialek": ["Baku", "Non-Baku", "Daerah", "Gaul"],
        "Penyuntingan Otomatis": ["Tanpa Sensor", "Disesuaikan", "Sensor Ketat"],
    };

    const handleOptionChange = (e) => {
        setSelectedOptions({ ...selectedOptions, [e.target.name]: e.target.value });
    };

    // src/components/TranscriptionModal.js (partial update)
    const handleGenerateContent = async () => {
        setLoading(true);
        setGeneratedContent("");
        setStep(3);

        const combinedConfig = {
            ...selectedOptions,
            "Catatan Tambahan": additionalNotes,
        };

        const jobId = uuidv4();
        const job = {
            job_id: jobId,
            status: "pending",
            type: "content-generation",
            title: `Content: ${transcription.title || "Untitled"}`,
        };

        addJob(job);

        try {
            updateJobStatus({ ...job, status: "processing" });

            const API_BASE_URL = process.env.NEXT_PUBLIC_API_BASE_URL || "http://127.0.0.1:3000";
            const response = await axios.post(
                `${API_BASE_URL}/generate/`,
                {
                    job_id: jobId,
                    transcription_id: transcription.id,
                    transcription: transcription.transcript,
                    gaya_bahasa: selectedOptions["Gaya Bahasa"],
                    kepadatan_informasi: selectedOptions["Kepadatan Informasi"],
                    sentimen: selectedOptions["Sentimen Terhadap Objek Berita"],
                    gaya_penyampaian: selectedOptions["Gaya Penyampaian"],
                    format_output: selectedOptions["Format Output"],
                    gaya_kutipan: selectedOptions["Gaya Kutipan"],
                    bahasa: selectedOptions["Pilihan Bahasa & Dialek"],
                    penyuntingan: selectedOptions["Penyuntingan Otomatis"],
                    catatan_tambahan: additionalNotes,
                    config: combinedConfig,
                },
                { withCredentials: true }
            );

            // No article content returned immediately; rely on polling
            console.log("Content generation started:", response.data);
            // Don’t setGeneratedContent here; wait for polling to update status
        } catch (error) {
            console.error("Error starting content generation:", error);
            updateJobStatus({ ...job, status: "failed" });
            if (onDone) onDone();
        } finally {
            setLoading(false);
        }
    };

    return (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex justify-center items-center">
            <div className="bg-white p-6 rounded-lg shadow-lg max-w-6xl w-full h-[80vh] flex flex-col">
                <div
                    className={`flex flex-grow transition-all duration-300 ${step === 1
                        ? "grid-cols-1"
                        : step === 2
                            ? "grid-cols-2"
                            : "grid-cols-3"
                        } grid gap-4 overflow-hidden`}
                >
                    <div className="p-4 overflow-y-auto">
                        <h2 className="text-2xl font-bold">
                            {transcription.title || "Transcription Details"}
                        </h2>
                        <p className="text-sm text-gray-600">
                            Source: {transcription.source}
                        </p>
                        {transcription.source === "YouTube" ? (
                            <iframe
                                className="aspect-video w-full h-auto my-2"
                                src={`https://www.youtube.com/embed/${new URL(transcription.video_url).searchParams.get("v")}`}
                                allowFullScreen
                            ></iframe>
                        ) : (
                            <audio controls className="w-full my-2">
                                <source src={audioSrc} type="audio/mp3" />
                                Your browser does not support the audio element.
                            </audio>
                        )}
                        <p className="text-gray-800 whitespace-pre-wrap">
                            {transcription.transcript}
                        </p>
                        {step === 1 && (
                            <button
                                onClick={() => setStep(2)}
                                className="mt-4 w-full bg-purple-500 text-white py-2 rounded-md"
                            >
                                Generate Content
                            </button>
                        )}
                    </div>
                    {step > 1 && (
                        <div className="p-4 overflow-y-auto">
                            <h3 className="text-xl font-bold">Generate Content</h3>
                            {Object.keys(selectedOptions).map((key) => (
                                <div key={key} className="mb-2">
                                    <label className="block font-semibold">
                                        {key}:
                                    </label>
                                    <select
                                        name={key}
                                        value={selectedOptions[key]}
                                        onChange={handleOptionChange}
                                        className="border rounded p-2 w-full bg-white"
                                    >
                                        {dropdownOptions[key].map((opt) => (
                                            <option key={`${key}-${opt}`} value={opt}>
                                                {opt}
                                            </option>
                                        ))}
                                    </select>
                                </div>
                            ))}
                            <div className="mb-2">
                                <label className="block font-semibold">
                                    Catatan Tambahan:
                                </label>
                                <textarea
                                    value={additionalNotes}
                                    onChange={(e) => setAdditionalNotes(e.target.value)}
                                    className="border rounded p-2 w-full bg-white"
                                    placeholder="Masukkan catatan tambahan (opsional)"
                                    rows={3}
                                />
                            </div>
                            <button
                                onClick={handleGenerateContent}
                                className="mt-4 w-full bg-green-500 text-white py-2 rounded-md"
                                disabled={loading}
                            >
                                {loading ? "Generating..." : "Generate"}
                            </button>
                        </div>
                    )}
                    {step === 3 && (
                        <div className="p-4 overflow-y-auto">
                            <h3 className="text-xl font-bold">Generated Content</h3>
                            <div className="border p-4 rounded-lg bg-gray-50">
                                <div
                                    className="generated-content"
                                    dangerouslySetInnerHTML={{
                                        __html: DOMPurify.sanitize(generatedContent),
                                    }}
                                />
                            </div>
                        </div>
                    )}
                </div>
                <div className="flex justify-between mt-4">
                    {step > 1 && (
                        <button
                            onClick={() => setStep(step - 1)}
                            className="bg-gray-500 text-white py-2 px-4 rounded-md"
                        >
                            Back
                        </button>
                    )}
                    <button
                        onClick={onClose}
                        className="bg-red-500 text-white py-2 px-4 rounded-md"
                    >
                        Close
                    </button>
                </div>
            </div>
        </div>
    );
}// src/components/TranscribeSection.js
"use client";

import { useState } from "react";
import axios from "axios";
import { useJobs } from "../hooks/useJobs";

export default function TranscribeSection() {
    const { addJob } = useJobs();
    const [youtubeUrl, setYoutubeUrl] = useState("");
    const [file, setFile] = useState(null);
    const [loading, setLoading] = useState(false);

    const API_BASE_URL = process.env.NEXT_PUBLIC_API_BASE_URL || "http://127.0.0.1:3000";

    const handleYouTubeTranscribe = async () => {
        if (!youtubeUrl) return;
        setLoading(true);
        try {
            const response = await axios.post(
                `${API_BASE_URL}/youtube/process-youtube/`,
                { youtube_url: youtubeUrl },
                { withCredentials: true } // Use cookies instead of token
            );

            const { job_id, youtube_title } = response.data;

            addJob({
                job_id,
                title: `YouTube: ${youtube_title}`,
                type: "transcription",
                source: "youtube",
                status: "pending",
            });
        } catch (error) {
            console.error("Error starting transcription:", error);
            throw error; // Let caller handle the error if needed
        } finally {
            setLoading(false);
        }
    };

    const handleFileUpload = (event) => {
        setFile(event.target.files[0]);
    };

    const handleUploadTranscribe = async () => {
        if (!file) return;
        setLoading(true);
        try {
            const formData = new FormData();
            formData.append("file", file);
            const response = await axios.post(
                `${API_BASE_URL}/upload/upload-audio/`,
                formData,
                {
                    withCredentials: true, // Use cookies instead of token
                    headers: { "Content-Type": "multipart/form-data" },
                }
            );

            addJob({
                job_id: response.data.job_id,
                title: file.name,
                type: "transcription",
                source: "upload",
                status: "pending",
            });
        } catch (error) {
            console.error("Error uploading file:", error);
            throw error; // Let caller handle the error if needed
        } finally {
            setLoading(false);
        }
    };

    return (
        <div className="bg-white p-6 rounded-lg shadow-md w-full max-w-2xl mx-auto">
            <h2 className="text-xl font-bold">Transcribe</h2>

            {/* YouTube Transcription */}
            <div className="space-y-2">
                <label htmlFor="youtubeUrl" className="block font-medium text-gray-700">
                    YouTube URL
                </label>
                <input
                    id="youtubeUrl"
                    type="text"
                    placeholder="https://www.youtube.com/watch?v=..."
                    value={youtubeUrl}
                    onChange={(e) => setYoutubeUrl(e.target.value)}
                    className="w-full p-2 border border-gray-300 rounded focus:outline-none focus:ring-1 focus:ring-blue-500"
                />
                <button
                    onClick={handleYouTubeTranscribe}
                    className="w-full bg-blue-500 hover:bg-blue-600 text-white py-2 rounded-md transition-colors"
                    disabled={loading}
                >
                    {loading ? "Processing..." : "Transcribe YouTube Video"}
                </button>
            </div>

            <hr className="border-gray-300 my-6" />

            {/* File Upload Transcription */}
            <div className="space-y-2">
                <label htmlFor="fileUpload" className="block font-medium text-gray-700">
                    Upload Audio/Video File
                </label>
                <input
                    id="fileUpload"
                    type="file"
                    onChange={handleFileUpload}
                    className="w-full text-sm text-gray-700
                        file:mr-4 file:py-2 file:px-4
                        file:rounded file:border-0
                        file:text-sm file:font-semibold
                        file:bg-green-50 file:text-green-700
                        hover:file:bg-green-100"
                />
                <p className="text-xs text-gray-500">
                    Allowed file types: <strong>.mp3, .mp4, .wav, .webm</strong>
                </p>
                <button
                    onClick={handleUploadTranscribe}
                    className="w-full bg-green-500 hover:bg-green-600 text-white py-2 rounded-md transition-colors"
                    disabled={loading}
                >
                    {loading ? "Uploading..." : "Upload & Transcribe File"}
                </button>
            </div>
        </div>
    );
}// src/hooks/useAuth.js
import { useState, useEffect } from "react";
import { useRouter } from "next/navigation";
import { getUser } from "../utils/api";

export default function useAuth() {
    const [user, setUser] = useState(null);
    const router = useRouter();

    useEffect(() => {
        getUser()
            .then((res) => {
                console.log("✅ User data fetched:", res.data); // The user object
                setUser(res.data);  // Store only the user payload
            })
            .catch(() => {
                localStorage.removeItem("token");
                router.push("/login");
            });
    }, [router]);

    return user;
}// src/hooks/useJobs.js
"use client";
import axios from "axios";
import { createContext, useContext, useState, useEffect, useCallback, useRef } from "react";

export function ProcessingQueue({ processingQueue, isLoading }) {  // Add isLoading prop
    useEffect(() => {
        console.log("🟢 ProcessingQueue Updated:", processingQueue);
    }, [processingQueue]);

    const sortedJobs = (processingQueue || []).slice().sort((a, b) => {
        const dateA = a.created_at ? new Date(a.created_at) : new Date(0);
        const dateB = b.created_at ? new Date(b.created_at) : new Date(0);
        return dateB - dateA;
    });

    return (
        <div>
            <h2 className="text-xl font-bold mb-4">Ongoing Jobs</h2>
            <div className="space-y-3">
                {isLoading ? (
                    <p className="text-gray-500">Fetching ongoing jobs...</p>
                ) : sortedJobs.length > 0 ? (
                    sortedJobs.map((job) => (
                        <div
                            key={job.job_id}
                            className={`p-4 rounded-lg shadow cursor-pointer transition ${job.status === "processing" ? "bg-blue-100" : "bg-gray-50"} hover:bg-gray-200`}
                        >
                            <p className="font-semibold">{job.title || "Untitled Job"}</p>
                            <p className="text-xs text-gray-500">Status: {job.status}</p>
                            {job.created_at && (
                                <p className="text-xs text-gray-400 mt-1">
                                    Created: {new Date(job.created_at).toLocaleString()}
                                </p>
                            )}
                            {job.completed_at && job.status === "completed" && (
                                <p className="text-xs text-gray-400">
                                    Completed: {new Date(job.completed_at).toLocaleString()}
                                </p>
                            )}
                        </div>
                    ))
                ) : (
                    <p className="text-gray-500">No ongoing jobs.</p>
                )}
            </div>
        </div>
    );
}

const JobsContext = createContext();
const API_BASE_URL = process.env.NEXT_PUBLIC_API_BASE_URL || "http://127.0.0.1:3000";

export function JobsProvider({ children }) {
    const [processingQueue, setProcessingQueue] = useState([]);
    const [isLoading, setIsLoading] = useState(true);  // Add loading state
    const queueRef = useRef(processingQueue);

    useEffect(() => {
        queueRef.current = processingQueue;
    }, [processingQueue]);

    const fetchOngoingJobs = async () => {
        try {
            setIsLoading(true);  // Set loading true before fetch
            const response = await axios.get(`${API_BASE_URL}/jobs/ongoing/`, {
                withCredentials: true,
            });
            console.log("Fetched ongoing jobs:", response.data);
            setProcessingQueue(response.data.map(job => ({
                job_id: job.job_id,
                status: job.status,
                created_at: job.created_at,
                completed_at: job.completed_at,
                title: job.title,
            })));
        } catch (error) {
            console.error("Failed to fetch ongoing jobs:", error);
        } finally {
            setIsLoading(false);  // Set loading false after fetch completes
        }
    };

    useEffect(() => {
        fetchOngoingJobs(); // Fetch ongoing jobs on mount
    }, []);

    const addJob = (job) => {
        setProcessingQueue((prev) => {
            const exists = prev.some((j) => j.job_id === job.job_id);
            if (!exists) {
                return [
                    ...prev,
                    {
                        ...job,
                        created_at: job.created_at || new Date().toISOString(),
                    },
                ];
            }
            return prev;
        });
    };

    const updateJobStatus = useCallback((updatedJob) => {
        setProcessingQueue((prev) => {
            let hasStatusChange = false;
            const updatedQueue = prev.map((job) => {
                if (job.job_id === updatedJob.job_id && job.status !== updatedJob.status) {
                    hasStatusChange = true;
                    const isCompleting = updatedJob.status === "completed" && !job.completed_at;
                    return {
                        ...job,
                        status: updatedJob.status,
                        completed_at: isCompleting ? new Date().toISOString() : job.completed_at,
                    };
                }
                return job;
            });
            return hasStatusChange ? updatedQueue : prev;
        });
    }, []);

    useEffect(() => {
        const fetchJobStatuses = async () => {
            const currentQueue = queueRef.current;
            if (currentQueue.length === 0) {
                console.log("⚠️ No jobs to fetch!");
                return;
            }
            if (typeof window === "undefined") {
                return;
            }
            console.log("🔄 Fetching job statuses for jobs:", currentQueue.map((job) => job.job_id));

            try {
                const jobsStatus = await Promise.all(
                    currentQueue.map(async (job) => {
                        try {
                            const res = await axios.get(
                                `${API_BASE_URL}/jobs/${job.job_id}/status`,
                                { withCredentials: true }
                            );
                            console.log(`✅ Fetched status for job ${job.job_id}:`, res.data.status);
                            return { job_id: job.job_id, status: res.data.status };
                        } catch (error) {
                            console.error(`❌ Error fetching job ${job.job_id} status:`, error.response?.status, error.message);
                            return { job_id: job.job_id, status: "failed" };
                        }
                    })
                );
                jobsStatus.forEach((jobStatus) => {
                    updateJobStatus(jobStatus);
                });
            } catch (error) {
                console.error("❌ Error polling job statuses:", error);
            }
        };

        const intervalId = setInterval(fetchJobStatuses, 5000);
        return () => clearInterval(intervalId);
    }, [updateJobStatus]);

    return (
        <JobsContext.Provider value={{ processingQueue, addJob, updateJobStatus, isLoading }}>
            {children}
        </JobsContext.Provider>
    );
}

export function useJobs() {
    return useContext(JobsContext);
}// src/hooks/useHistory.js
import { useState, useEffect } from "react";
import { fetchHistory } from "../utils/api";

export default function useHistory(user) {
    const [transcriptionHistory, setTranscriptionHistory] = useState([]);
    const [contentHistory, setContentHistory] = useState([]);

    const refreshHistory = async () => {
        if (!user) return;
        try {
            // Fetch both histories concurrently
            const [transcriptions, contents] = await fetchHistory();
            setTranscriptionHistory(
                Array.isArray(transcriptions.data) ? transcriptions.data : []
            );
            setContentHistory(
                Array.isArray(contents.data) ? contents.data : []
            );
        } catch (error) {
            console.error("Error refreshing history:", error);
        }
    };

    // Fetch history once on mount (or when user changes)
    useEffect(() => {
        refreshHistory();
    }, [user]);

    return { transcriptionHistory, contentHistory, refreshHistory };
}