# backend/utils/transcribe_utils.py
import os
import requests
import subprocess
from typing import List
from backend.config import settings
import shutil
import logging

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

MAX_SIZE = 25 * 1024 * 1024  # 25 MB in bytes


def transcribe_audio_with_whisper(audio_file_path: str) -> str:
    file_size = os.path.getsize(audio_file_path)
    logger.info(
        f"Starting transcription for {audio_file_path} (size: {file_size} bytes)")
    if file_size <= MAX_SIZE:
        return transcribe_single_file(audio_file_path)
    else:
        chunk_paths = split_audio_file(audio_file_path, segment_duration=300)
        transcripts = []
        for chunk in chunk_paths:
            transcript = transcribe_single_file(chunk)
            transcripts.append(transcript)
        chunk_dir = os.path.dirname(chunk_paths[0])
        shutil.rmtree(chunk_dir, ignore_errors=True)
        logger.info(
            f"Completed transcription for {audio_file_path} with {len(chunk_paths)} chunks")
        return "\n".join(transcripts)


def transcribe_single_file(audio_file_path: str) -> str:
    api_key = settings.OPENAI_API_KEY
    url = "https://api.openai.com/v1/audio/transcriptions"
    headers = {"Authorization": f"Bearer {api_key}"}
    data = {"model": "whisper-1"}
    with open(audio_file_path, "rb") as f:
        files = {"file": (os.path.basename(audio_file_path), f, "audio/mpeg")}
        logger.info(f"Sending {audio_file_path} to Whisper API")
        response = requests.post(url, headers=headers, data=data, files=files)
    if response.status_code != 200:
        logger.error(
            f"Whisper API error for {audio_file_path}: {response.status_code} - {response.text}")
        raise ValueError(
            f"Whisper API error {response.status_code}: {response.text}")
    result = response.json()
    logger.info(f"Transcription completed for {audio_file_path}")
    return result.get("text", "")


def split_audio_file(audio_file_path: str, segment_duration: int) -> List[str]:
    output_dir = os.path.join(os.path.dirname(audio_file_path), "chunks")
    os.makedirs(output_dir, exist_ok=True)
    base_name = os.path.splitext(os.path.basename(audio_file_path))[0]
    output_pattern = os.path.join(output_dir, f"{base_name}_chunk_%03d.mp3")

    command = [
        "ffmpeg",
        "-i", audio_file_path,
        "-vn",
        "-acodec", "mp3",
        "-f", "segment",
        "-segment_time", str(segment_duration),
        output_pattern
    ]
    logger.info(f"Splitting {audio_file_path} into chunks")
    try:
        result = subprocess.run(command, check=True,
                                stderr=subprocess.PIPE, text=True)
        logger.debug(f"FFmpeg output for {audio_file_path}: {result.stderr}")
    except subprocess.CalledProcessError as e:
        logger.error(f"FFmpeg error splitting {audio_file_path}: {e.stderr}")
        raise RuntimeError(f"FFmpeg failed: {e.stderr}")

    chunk_files = sorted(
        [os.path.join(output_dir, f) for f in os.listdir(output_dir)
         if f.startswith(f"{base_name}_chunk_") and f.endswith(".mp3")]
    )
    if not chunk_files:
        logger.error(f"No chunks generated for {audio_file_path}")
        raise RuntimeError("No chunks generated by FFmpeg")
    logger.info(f"Generated {len(chunk_files)} chunks for {audio_file_path}")
    return chunk_files
